___.fundamentals
= assignment
== equality
% remaining
/ division
// integer division
+ addition for int or float; appending for str
- subtraction
* multiplication for int or float; times giving a str
end='any_character' giving the code side by side placing any_character between the phrases
range(any_number) an interval till any_number-1



___.types
str
float
int
list
tuple
bool    --->>  any_assignment_name = True, then we may return or print it as any_assignment_name for TRUE or not any_assignment_name for FALSE
dict



a___Variables, Expressions, Statements
->for n decimal point -->> "{:.nf}".format(any_thing)
->to write ' in a string put \' in order to differentiate it for pycharm
->to read 2 integer inputs from the user->>  x, y = map(int, input().split())
->to read multiple (int)inputs from the user in a list recognizing the spaces to separate the items->> list(map(int, input().split()))



b___Conditional Execution
if.........:
    .......
elif.......:
    .......
else:
    .......



c___Loops and Iterations
indefinite loop ---> while
definite loop   ---> for

while......:
    .......
for i in ..:
    .......

continue \ break



d___Nested Loops
for i in ..:
    .......
    for (while) l in ..:
        .......



e___Functions
                    1.definite functions
def function_name(variable):
    a
     n
      y
       c
        o
         d
          e
    return ....
print(function_name(my_variable))

def function_name(variable):
    a
     n
      y
       c
        o
         d
          e
    print(....)
function_name(my_variable))

->for unknown number of variables->>  def function_name(*variable):
                                          a
                                           n
                                            y
                                             c
                                              o
                                               d
                                                e
                    2.indefinite (anonymous) function -lambda-
new_assignment = lambda arguments : expression ->> There could be multiple arguments but one expression.
->to apply this lambda function for any variable x->>  new_assignment(x)



f___Lists
->to create a list->>  new_list = list()
                       new_list = []
->to get the item whose index no is known->>  new_list[index_no]
->index system->>  from beginning till end: 0,1,2...     from end till beginning: -1,-2,-3...
->for the items from index a to index (b-1)->>  new_list[a:b]
->to detect the elements the reverse order->>  new_list[-n:]; n is len(new_list)-1 or new_list[::-1]
->to append an element->>  new_list.append(new_item)
->to remove an element->>  new_list.remove(an_item)
->to insert an element to a specific place->>  new_list(index_no, new_item) ---not affecting any other available element
->to change an element whose index no is known with a new one->>  new_list[index_no] = new_element
->to count occurrence of an element->>  new_list.count(element)
->to find index no of an element->>  new_list.index(element)
->to reverse the order of the elements->>  new_list.reverse()
->to sort the elements alphanumerically->>  new_list.sort()
->to remove an item whose index no is known and return latest version of the list->> new_list.pop(index_no)
->if we assign a new variable to the popped list and then print it, we get the popped item
->to find number of elements->>  len(new_list)
->to give a string of the elements separated by any_character->>  'any_character'.join(new_list)
->to create a list from any input given before, recognizing the character so that a list can be generated by separating from that character->> any_input.split(any_character)
->to get both index no and the corresponding item->> for i, l enumerate(new_list):
                                                  print(i, l)



g___Tuples
Tuples are immutable.
new_tuple = tuple()
new_tuple = (a,b)
->to have a tuple like (m, ); we need to assign like new_tuple = (m, ) not like new_tuple = (m)
same index properties
same count properties
same len property



h___Strings
Strings are immutable.
new_str = '......'
->to count occurrence of a character->>  new_str.count(character)
->to turn upper case->>  new_str.upper()
->to turn lower case->>  new_str.lower()
->to check whether string is uppercase->>  new_str.isupper()
->to check whether string is lowercase->> new_str.islower()
->to capitalize the first letter and lower the remaining letters->> new_str.capitalize()
->to learn index no of a character->>  new_str.find(character) or new_str.index(character)
->to check whether string starts with a character(s)->>  new_str.startswith(character)
->to check whether string ends with a character(s)->>  new_str.endswith(character)
->to remove any_character from both left and right side->> new_str.strip(any_character)
->to remove any_character from left side->>  new_str.lstrip(any_character)
->to remove any_character from right side->>  new_str.rstrip(any_character)
->to replace a phrase with a new phrase->>  new_str.replace('old_phrase', 'new_phrase')
->to check whether any_character is a letter->> new_str.isalpha(any_character)
->to check whether any_character is a digit->> new_str.isdigit(any_character)



i___Files
Let's assume we have a file namely my_file.txt
->to open the file by default->>  ff = open('my_file.txt')  (default command is 'r' which means read)
->to open the file by reading->>  ff = open('my_file.txt', 'r')
->to open the file by writing->>  ff = open('my_file.txt', 'w')
                                  a
                                  n
                                  y
                                  c
                                  o
                                  d
                                  e
                                  ff.close()
->to get lines in the file->>  for i in ff:
                                   .......
->Sometimes you need to remove redundant spaces!
->to write a new line->> ff.write(any_thing, '\n')



j___Dictionaries
new_dict = dict()
new_dict = {}   #{a: a_0, b: b_0, c: c_0}---> a,b,c are keys and a_0,b_0,c_0 are values.
->new_dict[any_key] = corresponding_value
->to append a new key-value pair->>  new_dict[new_key] = new_value
->to append a new value to an already available value which is already given as a list so that we could append->>  new_dict[any_key].append(new_value)
->to get the items in a list of tuples->> new_dict.items()
->to get the keys->> new_dict.keys()
->to get the values->> new_dict.values()
->to get a specific value of a key new_dict.get('key_name')



k___Sets
new_set = set()
A set can have unique elements.
->to find union of 2 sets->>  set1.union(set2) or set1|set2
->to find intersection of 2 sets->>  set1.intersection(set2) or set1&set2
->to find difference of 2 sets->>  set1.difference(set2) or set1-set2 
